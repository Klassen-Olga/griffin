<!DOCTYPE html>
<html>
<head>
    <title>Duplex</title>
    <meta charset="UTF-8"/>
    <link href="/styles.css" rel="stylesheet">
</head>


<body>
<script>
  const roomId = "<%= roomId %>"
</script>

<video id="selfStream" controls="false" playsinline autoplay muted></video>
<br>
<button onclick="addAudioStream('audio')" id="enable-audio">Audio on</button>
<button onclick="addVideoStream('video')" id="enable-audio">Video on</button>

<button onclick="enter('audio')" id="enable-audio">Check</button>

<br>
<div id="foreignVideoContainer" class="video-container">

</div>
<video id="foreignStream" playsinline autoplay muted></video>
<script src="/socket.io/socket.io.js"></script>
</body>
</html>
<script>


  const peerConnections = {};
  const config = {
    iceServers: [
      {
        urls: ["stun:stun.l.google.com:19302"]
      }
    ]
  };
  const constraints = {
    video: {facingMode: "user"}
  };
  const socket = io.connect(window.location.origin);


  const selfVideoElement = document.getElementById("selfStream");



  /*
  *

  * */

    function addAudioStream(trackType) {
      if (Object.keys(peerConnections).length !== 0){
        navigator.mediaDevices.getUserMedia({audio: true})
          .then( async stream => {
            if (selfVideoElement.srcObject!==null){
              const audioTracks=stream.getAudioTracks();
              let localStream=selfVideoElement.srcObject;
              localStream.addTrack(audioTracks[0]);
              selfVideoElement.srcObject=null;
              selfVideoElement.srcObject=localStream;
            }
            else{
              selfVideoElement.srcObject=stream;
            }



            /*
                    console.log(selfVideoElement.srcObject.getTracks().length);
            */


            for (var key in peerConnections) {
              if (peerConnections.hasOwnProperty(key)) {
                const audioTracks=stream.getAudioTracks();
                peerConnections[key].addTrack(audioTracks[0], selfVideoElement.srcObject);
                let sdp= await  peerConnections[key].createOffer({ offerToReceiveVideo: true, offerToReceiveAudio: true });
                await peerConnections[key].setLocalDescription(sdp);
                await socket.emit("audioOnOffer", peerConnections[key].localDescription, key);
              }
            }
          })
          .catch(error => console.error(error));
      }
      else{
        navigator.mediaDevices.getUserMedia({audio: true})
          .then( stream => {
            if (selfVideoElement.srcObject!==null){
              const audioTracks=stream.getAudioTracks();
              let localStream=selfVideoElement.srcObject;
              localStream.addTrack(audioTracks[0]);
              selfVideoElement.srcObject=null;
              selfVideoElement.srcObject=localStream;
            }
            else{
              selfVideoElement.srcObject=stream;
            }
          });

            /*
                    console.log(selfVideoElement.srcObject.getTracks().length);
            */



      }


  }
  function addVideoStream(trackType) {
    if (Object.keys(peerConnections).length !== 0){
      navigator.mediaDevices.getUserMedia({video: true})
        .then( async stream => {
          if (selfVideoElement.srcObject!==null){
            const videoTracks=stream.getVideoTracks();
            let localStream=selfVideoElement.srcObject;
            localStream.addTrack(videoTracks[0]);
            selfVideoElement.srcObject=null;
            selfVideoElement.srcObject=localStream;
          }
          else{
            selfVideoElement.srcObject=stream;
          }



          /*
                  console.log(selfVideoElement.srcObject.getTracks().length);
          */


          for (let key in peerConnections) {
            if (peerConnections.hasOwnProperty(key)) {
              const audioTracks=stream.getVideoTracks();

              peerConnections[key].addTrack(audioTracks[0], selfVideoElement.srcObject);
              let sdp= await  peerConnections[key].createOffer({ offerToReceiveVideo: true, offerToReceiveAudio: true });
              await peerConnections[key].setLocalDescription(sdp);
              await socket.emit("audioOnOffer", peerConnections[key].localDescription, key);
            }
          }
        })
        .catch(error => console.error(error));
    }
    else{
      navigator.mediaDevices.getUserMedia({video: true})
        .then( stream => {
          if (selfVideoElement.srcObject!==null){
            const videoTracks=stream.getVideoTracks();
            let localStream=selfVideoElement.srcObject;
            localStream.addTrack(videoTracks[0]);
            selfVideoElement.srcObject=null;
            selfVideoElement.srcObject=localStream;
          }
          else{
            selfVideoElement.srcObject=stream;
          }
        });

      /*
              console.log(selfVideoElement.srcObject.getTracks().length);
      */



    }


  }
  socket.emit("newUser");

  function enter(){
    socket.emit("newUser");

  }

  socket.on("audioOnAnswer", (userWhichAddedAudioTrack, description)=>{
    peerConnections[userWhichAddedAudioTrack]
      .setRemoteDescription(description)
      .then(() => peerConnections[userWhichAddedAudioTrack].createAnswer())
      .then(sdp => peerConnections[userWhichAddedAudioTrack].setLocalDescription(sdp))
      .then(() => {
        socket.emit("answer", userWhichAddedAudioTrack, peerConnections[userWhichAddedAudioTrack].localDescription);
      });

  })
  // 1)
  socket.on("newUser", (newUserId) => {
    socket.emit("requestForOffer", newUserId);
  });


  // 2) my conn
  socket.on("requestForOffer", oldUserId => {
    //create peer connection
    const peerConnection = createPeerConnection(oldUserId);

    peerConnections[oldUserId] = peerConnection;


    //if  any iceCandidate appears, emit candidate event
    peerConnection.onicecandidate = event => {
      if (event.candidate) {
        console.log("event-candiate-client: " + event.candidate)
        socket.emit("candidate", oldUserId, event.candidate);
      }
    };
    //create session description and send it to watcher
    peerConnection
      .createOffer({ offerToReceiveVideo: true, offerToReceiveAudio: true })
      .then(sdp => peerConnection.setLocalDescription(sdp))
      .then(() => {
        socket.emit("offer", oldUserId, peerConnection.localDescription);
      });
  });


  // 3-4) their
  socket.on("offer", (newUserId, description) => {
    const peerConnection = createPeerConnection(newUserId);

    peerConnections[newUserId] = peerConnection;
    peerConnection
      .setRemoteDescription(description)
      .then(() => peerConnection.createAnswer())
      .then(sdp => peerConnection.setLocalDescription(sdp))
      .then(() => {
        socket.emit("answer", newUserId, peerConnection.localDescription);
      });

    peerConnection.onicecandidate = event => {
      if (event.candidate) {
        socket.emit("candidate", newUserId, event.candidate);
      }
    };
  });


  // 5)
  socket.on("answer", (oldUserId, description) => {
    peerConnections[oldUserId].setRemoteDescription(description);
  });


  socket.on("candidate", (id, candidate) => {

    peerConnections[id].addIceCandidate(new RTCIceCandidate(candidate));

    console.log(JSON.stringify(peerConnections));

  });


  socket.on("disconnectPeer", id => {
    peerConnections[id].iceConnectionState === 'disconnected';
    peerConnections[id].close();
    console.log(JSON.stringify(peerConnections));
  });


  function createPeerConnection(id) {

    const peerConnection = new RTCPeerConnection(config);
    peerConnection.id=id;
    let stream = selfVideoElement.srcObject;
/*
    console.log(selfVideoElement.srcObject.getTracks().length + ' tracks while creating a peer connection');
*/

    if (stream!==null){
      stream.getTracks().forEach(track => {
        console.log(peerConnection.addTrack(track, stream));
      })
    }



    peerConnection.onnegotiationneeded=function(){

      console.log('NEGOTIATION NEEDED');
    }
    peerConnection.ontrack = (event) => {
      console.log('On track event for user with id '+id+' '+' number of tracks '+JSON.stringify(event.streams[0].getTracks().length));

      let video =document.getElementById(id);

      if (document.getElementById(id)===null){
        let foreignVideoContainer = document.getElementById("foreignVideoContainer");
        let video = document.createElement("video");
        video.setAttribute('id', id);
        video.setAttribute("autoplay", true);
        video.setAttribute("playsinline", true);
        video.setAttribute("controls", false);
        video.srcObject = event.streams[0];
        foreignVideoContainer.appendChild(video);

      }
      else{
        video.srcObject=null;
        video.srcObject=event.streams[0];
      }

    };

    return peerConnection;
  }


  window.onunload = window.onbeforeunload = () => {
    socket.close();
  };
</script>
