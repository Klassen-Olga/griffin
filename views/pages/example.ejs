<!DOCTYPE html>
<html>
<head>
    <title>Duplex</title>
    <meta charset="UTF-8"/>
    <link href="/styles.css" rel="stylesheet">
</head>


<body>
<script>
  const roomId = "<%= roomId %>"
</script>

<video id="selfStream" controls="false" playsinline autoplay muted></video>
<br>
<button onclick="addAudioStream('audio')" id="enable-audio">Audio on</button>

<br>
<div id="foreignVideoContainer" class="video-container">

</div>
<video id="foreignStream" playsinline autoplay muted></video>
<script src="/socket.io/socket.io.js"></script>
</body>
</html>
<script>


  const peerConnections = {};
  const config = {
    iceServers: [
      {
        urls: ["stun:stun.l.google.com:19302"]
      }
    ]
  };
  const constraints = {
    video: {facingMode: "user"}
  };
  const socket = io.connect(window.location.origin);


  const selfVideoElement = document.getElementById("selfStream");

  navigator.mediaDevices.getUserMedia({video: true})
    .then(stream => {
      selfVideoElement.srcObject = stream;
      socket.emit("newUser");

    })
    .catch(error => console.error(error));

    function addAudioStream(trackType) {
    navigator.mediaDevices.getUserMedia({audio: true})
      .then( async stream => {
        const audioTracks=stream.getAudioTracks();
        let localStream=selfVideoElement.srcObject;

        localStream.addTrack(audioTracks[0], localStream);
        selfVideoElement.srcObject=null;
        selfVideoElement.srcObject=localStream;


        for (var key in peerConnections) {
          if (peerConnections.hasOwnProperty(key)) {
            peerConnections[key].addTrack(audioTracks[0], selfVideoElement.srcObject);
            let sdp= await  peerConnections[key].createOffer();
            await peerConnections[key].setLocalDescription(sdp);
            await socket.emit("audioOnOffer", peerConnections[key].localDescription, key);
          }
        }
      })
      .catch(error => console.error(error));
  }


  socket.on("audioOnAnswer", (userWhichAddedAudioTrack, description)=>{
    peerConnections[userWhichAddedAudioTrack]
      .setRemoteDescription(description)
      .then(() => peerConnections[userWhichAddedAudioTrack].createAnswer())
      .then(sdp => peerConnections[userWhichAddedAudioTrack].setLocalDescription(sdp))
      .then(() => {
        socket.emit("answer", userWhichAddedAudioTrack, peerConnections[userWhichAddedAudioTrack].localDescription);
      });

  })
  // 1)
  socket.on("newUser", (newUserId) => {
    socket.emit("requestForOffer", newUserId);
  });


  // 2) my conn
  socket.on("requestForOffer", oldUserId => {
    //create peer connection
    const peerConnection = createPeerConnection(oldUserId);

    peerConnections[oldUserId] = peerConnection;


    //if  any iceCandidate appears, emit candidate event
    peerConnection.onicecandidate = event => {
      if (event.candidate) {
        console.log("event-candiate-client: " + event.candidate)
        socket.emit("candidate", oldUserId, event.candidate);
      }
    };
    //create session description and send it to watcher
    peerConnection
      .createOffer()
      .then(sdp => peerConnection.setLocalDescription(sdp))
      .then(() => {
        socket.emit("offer", oldUserId, peerConnection.localDescription);
      });
  });


  // 3-4) their
  socket.on("offer", (newUserId, description) => {
    const peerConnection = createPeerConnection(newUserId);

    peerConnections[newUserId] = peerConnection;
    peerConnection
      .setRemoteDescription(description)
      .then(() => peerConnection.createAnswer())
      .then(sdp => peerConnection.setLocalDescription(sdp))
      .then(() => {
        socket.emit("answer", newUserId, peerConnection.localDescription);
      });

    peerConnection.onicecandidate = event => {
      if (event.candidate) {
        socket.emit("candidate", newUserId, event.candidate);
      }
    };
  });


  // 5)
  socket.on("answer", (oldUserId, description) => {
    peerConnections[oldUserId].setRemoteDescription(description);
  });


  socket.on("candidate", (id, candidate) => {

    peerConnections[id].addIceCandidate(new RTCIceCandidate(candidate));

    console.log(JSON.stringify(peerConnections));

  });


  socket.on("disconnectPeer", id => {
    peerConnections[id].iceConnectionState === 'disconnected';
    peerConnections[id].close();
    console.log(JSON.stringify(peerConnections));
  });


  function createPeerConnection(id) {

    const peerConnection = new RTCPeerConnection(config);
    peerConnection.id=id;
    let stream = selfVideoElement.srcObject;
    console.log(stream.getTracks().length+' length of tracks');
    stream.getTracks().forEach(track => {
      console.log(peerConnection.addTrack(track, stream));
    })



    peerConnection.onnegotiationneeded=function(){
      console.log('NEGOTIATION NEEDED');
    }
    peerConnection.ontrack = (event) => {
      let video =document.getElementById(id);

      if (document.getElementById(id)===null){
        console.log(JSON.stringify(event.streams[0].getVideoTracks().length));
        console.log(JSON.stringify(event.streams[0].getAudioTracks().length));
        let foreignVideoContainer = document.getElementById("foreignVideoContainer");
        let video = document.createElement("video");
        video.setAttribute('id', id);
        video.setAttribute("autoplay", true);
        video.setAttribute("playsinline", true);
        video.setAttribute("controls", false);
        video.srcObject = event.streams[0];
        foreignVideoContainer.appendChild(video);

      }
      else{
        video.srcObject=null;
        video.srcObject=event.streams[0];
      }



      /*foreignStream.srcObject=event.streams[0];
      console.log("track "+ event.streams[0].getTracks().length);*/
    };

    return peerConnection;
  }



  function unmute() {
    console.log("Enabling audio")
    foreignStream.muted = false;
  }

  window.onunload = window.onbeforeunload = () => {
    socket.close();
  };
</script>
