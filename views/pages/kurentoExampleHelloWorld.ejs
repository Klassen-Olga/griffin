<html>
<body>
<h2>Local video playback</h2>

<video style=" margin:auto;display: block; width: 40%" id="localVideo" autoplay playsinline ></video>
<video controls="false" style=" margin:auto;display: block; width: 40%" id="remoteVideo" autoplay playsinline ></video>
<button onclick="start()">Start</button>
<button onclick="stop()">Stop</button>
</body>
</html>
<script src="script/kurento-utils.min.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script>

    var socket=io();
    var localVideo=document.getElementById('localVideo');
    var remoteVideo=document.getElementById('remoteVideo');
    // handles the WebRTC communication.
    var webRtcPeer=null;

    function start(){
	    var options = {
		    localVideo: localVideo,
		    remoteVideo: remoteVideo,
		    onicecandidate : (candidate)=>{
		    	socket.emit('onIceCandidate', candidate);
            }
	    }

	    webRtcPeer = kurentoUtils.WebRtcPeer.WebRtcPeerSendrecv(options, function(error) {
		    if(error){
			    console.log(error);
			    return;
            }
		    //generate sdp offer
		    //onoffer callback sends offer to another peer
		    this.generateOffer(onOffer);
	    });
    }
    function stop() {

    	if (webRtcPeer){
    		webRtcPeer.dispose();
    		webRtcPeer=null;
    		socket.emit('stop');
        }
    }
    function onOffer(err, offer){
	    socket.emit('start', offer);
    }
    socket.on('startResponse', answer=>{
	    webRtcPeer.processAnswer(answer);

    });
    socket.on('iceCandidate', candidate=>{
    	webRtcPeer.addIceCandidate(candidate);
    })

    window.onbeforeunload = function() {
	    socket.close();
    }
/*
*
* var minimist = require('minimist');
var kurento = require('kurento-client');

var kurentoClient = null;
var candidatesQueue = {};
var sessions = {};

// constants
var argv = minimist(process.argv.slice(2), {
	default: {
		as_uri: 'http://localhost:3000/kurentoExampleHelloWorld',
		ws_uri: 'ws://localhost:8888/kurento'
	}
});

io.on('connection', socket=>{
	//receive candidate from client and save to candidate list of user and add to endpoint
	socket.on('onIceCandidate', _candidate=>{
		var candidate = kurento.getComplexType('IceCandidate')(_candidate);

		// existing user receives new candidate
		if (sessions[socket.id]) {
			console.info('Sending candidate');
			var webRtcEndpoint = sessions[socket.id].webRtcEndpoint;
			webRtcEndpoint.addIceCandidate(candidate);
		}
		else {
			// end point for this user is not available yet,
			// candidates will be stored in queue and then will enter in first if
			console.info('Queueing candidate');
			if (!candidatesQueue[socket.id]) {
				candidatesQueue[socket.id] = [];
			}
			candidatesQueue[socket.id].push(candidate);
		}
	});
	socket.on('start', offer=>{

		getKurentoClient((error, kurentoClient)=>{

			// .create() - point where application communicates with media server AS--->KMS
			//pipeline- result returned from KMS AS<---KMS
			kurentoClient.create('MediaPipeline', (err, pipeline)=>{
				// .create() - point where application communicates with media server AS--->KMS
				//webrtsEndPoint - result returned from KMS AS<---KMS
				pipeline.create('WebRtcEndpoint', (err, webRtcEndpoint)=>{

					if (candidatesQueue[socket.id]) {
						while(candidatesQueue[socket.id].length) {
							var candidate = candidatesQueue[socket.id].shift();
							webRtcEndpoint.addIceCandidate(candidate);
						}
					}

					webRtcEndpoint.connect(webRtcEndpoint, err=>{
						webRtcEndpoint.on('OnIceCandidate', event=>{
							var candidate = kurento.getComplexType('IceCandidate')(event.candidate);

							socket.emit('iceCandidate', candidate);
						});
						webRtcEndpoint.processOffer(offer, (error, answer)=>{
							sessions[socket.id] = {
								'pipeline' : pipeline,
								'webRtcEndpoint' : webRtcEndpoint
							}
							socket.emit('startResponse', answer);
						});
						webRtcEndpoint.gatherCandidates(function(error) {
							if (error) {
								console.log(error);
							}
						});
					});

				})
			})
		});

	});
	socket.on('stop', ()=>{
		if (sessions[socket.id]){
			let pipeline= sessions[socket.id].pipeline;
			console.info('Releasing pipeline');
			pipeline.release();

			delete sessions[socket.id];
			delete candidatesQueue[socket.id];
		}
	});
});
function getKurentoClient(callback) {
	if (kurentoClient !== null) {
		return callback(null, kurentoClient);
	}

	kurento(argv.ws_uri, function(error, _kurentoClient) {
		if (error) {
			console.log("Could not find media server at address " + argv.ws_uri);
			return callback("Could not find media server at address" + argv.ws_uri
				+ ". Exiting with error " + error);
		}

		kurentoClient = _kurentoClient;
		callback(null, kurentoClient);
	});
}




* */
</script>